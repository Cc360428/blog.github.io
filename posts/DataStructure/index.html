<!DOCTYPE html>













<html lang="zh-CN"
  
>

  <!--
  The Head
-->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Allow having a localized datetime different from the appearance language -->
  

  

    

    

  

  

  

  
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="DataStructure（02142）" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="数据结构导论（02142） 第一章 概论（重点）" />
<meta property="og:description" content="数据结构导论（02142） 第一章 概论（重点）" />
<link rel="canonical" href="http://localhost:4000/blog.github.io/posts/DataStructure/" />
<meta property="og:url" content="http://localhost:4000/blog.github.io/posts/DataStructure/" />
<meta property="og:site_name" content="Cc" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-03-31T21:19:55+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="DataStructure（02142）" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-03-31T21:19:55+08:00","datePublished":"2022-03-31T21:19:55+08:00","description":"数据结构导论（02142） 第一章 概论（重点）","headline":"DataStructure（02142）","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog.github.io/posts/DataStructure/"},"url":"http://localhost:4000/blog.github.io/posts/DataStructure/"}</script>
<!-- End Jekyll SEO tag -->

  

  <title>DataStructure（02142） | Cc
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/blog.github.io/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/blog.github.io/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/blog.github.io/assets/img/favicons/favicon-16x16.png">
<link rel="manifest" href="/blog.github.io/assets/img/favicons/site.webmanifest">
<link rel="shortcut icon" href="/blog.github.io/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Cc">
<meta name="application-name" content="Cc">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/blog.github.io/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  

    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin>
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">

  

  <!-- GA -->
  

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css">

  <link rel="stylesheet" href="/blog.github.io/assets/css/style.css">

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css">
  

  
    <!-- Manific Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css">
  

  <!-- JavaScript -->

  <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>

  
    <!--
  Switch the mode between dark and light.
-->

<script type="text/javascript">
  class ModeToggle {
    static get MODE_KEY() { return "mode"; }
    static get MODE_ATTR() { return "data-mode"; }
    static get DARK_MODE() { return "dark"; }
    static get LIGHT_MODE() { return "light"; }
    static get ID() { return "mode-toggle"; }

    constructor() {
      if (this.hasMode) {
        if (this.isDarkMode) {
          if (!this.isSysDarkPrefer) {
            this.setDark();
          }
        } else {
          if (this.isSysDarkPrefer) {
            this.setLight();
          }
        }
      }

      let self = this;

      /* always follow the system prefers */
      this.sysDarkPrefers.addEventListener("change", () => {
        if (self.hasMode) {
          if (self.isDarkMode) {
            if (!self.isSysDarkPrefer) {
              self.setDark();
            }

          } else {
            if (self.isSysDarkPrefer) {
              self.setLight();
            }
          }

          self.clearMode();
        }

        self.notify();

      });

    } /* constructor() */

    get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); }

    get isSysDarkPrefer() { return this.sysDarkPrefers.matches; }

    get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; }

    get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; }

    get hasMode() { return this.mode != null; }

    get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); }

    /* get the current mode on screen */
    get modeStatus() {
      if (this.isDarkMode
        || (!this.hasMode && this.isSysDarkPrefer)) {
        return ModeToggle.DARK_MODE;
      } else {
        return ModeToggle.LIGHT_MODE;
      }
    }

    setDark() {
      $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE);
      sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE);
    }

    setLight() {
      $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE);
      sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE);
    }

    clearMode() {
      $('html').removeAttr(ModeToggle.MODE_ATTR);
      sessionStorage.removeItem(ModeToggle.MODE_KEY);
    }

    /* Notify another plugins that the theme mode has changed */
    notify() {
      window.postMessage({
        direction: ModeToggle.ID,
        message: this.modeStatus
      }, "*");
    }

  } /* ModeToggle */

  const toggle = new ModeToggle();

  function flipMode() {
    if (toggle.hasMode) {
      if (toggle.isSysDarkPrefer) {
        if (toggle.isLightMode) {
          toggle.clearMode();
        } else {
          toggle.setLight();
        }

      } else {
        if (toggle.isDarkMode) {
          toggle.clearMode();
        } else {
          toggle.setDark();
        }
      }

    } else {
      if (toggle.isSysDarkPrefer) {
        toggle.setLight();
      } else {
        toggle.setDark();
      }
    }

    toggle.notify();

  } /* flipMode() */

</script>

  
</head>


  <body data-spy="scroll" data-target="#toc" data-topbar-visible="true">

    <!--
  The Side Bar
-->

<div id="sidebar" class="d-flex flex-column align-items-end">
  <div class="profile-wrapper text-center">
    <div id="avatar">
      <a href="/blog.github.io/" class="mx-auto">
        
        
        <img src="https://cc360428.github.io/assets/img/favicons/all.png" alt="avatar" onerror="this.style.display='none'">
        
      </a>
    </div>

    <div class="site-title mt-3">
      <a href="/blog.github.io/">Cc</a>
    </div>
    <div class="site-subtitle font-italic">你好!</div>

  </div><!-- .profile-wrapper -->

  <ul class="w-100">

    <!-- home -->
    <li class="nav-item">
      <a href="/blog.github.io/" class="nav-link">
        <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i>
        <span>首页</span>
      </a>
    </li>
    <!-- the real tabs -->
    
    <li class="nav-item">
      <a href="/blog.github.io/categories/" class="nav-link">
        <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i>
        

        <span>分类</span>
      </a>
    </li> <!-- .nav-item -->
    
    <li class="nav-item">
      <a href="/blog.github.io/tags/" class="nav-link">
        <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i>
        

        <span>标签</span>
      </a>
    </li> <!-- .nav-item -->
    
    <li class="nav-item">
      <a href="/blog.github.io/archives/" class="nav-link">
        <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i>
        

        <span>归档</span>
      </a>
    </li> <!-- .nav-item -->
    
    <li class="nav-item">
      <a href="/blog.github.io/about/" class="nav-link">
        <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i>
        

        <span>关于</span>
      </a>
    </li> <!-- .nav-item -->
    

  </ul> <!-- ul.nav.flex-column -->

  <div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center">

    
    <button class="mode-toggle btn" aria-label="Switch Mode">
      <i class="fas fa-adjust"></i>
    </button>

    
    <span class="icon-border"></span>
    
    

    
    

    
    <a href="https://github.com/Cc360428" aria-label="github" target="_blank" rel="noopener" >
      <i class="fab fa-github"></i>
    </a>
    

    
    

    
    <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener" >
      <i class="fab fa-twitter"></i>
    </a>
    

    
    

    
    <a href="
    javascript:location.href = 'mailto:' + ['li_chao_cheng','163.com'].join('@')" aria-label="email" >
      <i class="fas fa-envelope"></i>
    </a>
    

    
    

    
    <a href="/blog.github.io/feed.xml" aria-label="rss" >
      <i class="fas fa-rss"></i>
    </a>
    

    

  </div> <!-- .sidebar-bottom -->

</div><!-- #sidebar -->


    <!--
  The Top Bar
-->

<div id="topbar-wrapper" class="row justify-content-center">
  <div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between">
    <span id="breadcrumb">

    

    

      

        
          <span>
            <a href="/blog.github.io/">
              首页
            </a>
          </span>

        

      

        

      

        

          
            <span>DataStructure（02142）</span>
          

        

      

    

    </span><!-- endof #breadcrumb -->

    <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i>

    <div id="topbar-title">
      文章
    </div>

    <i id="search-trigger" class="fas fa-search fa-fw"></i>
    <span id="search-wrapper" class="align-items-center">
      <i class="fas fa-search fa-fw"></i>
      <input class="form-control" id="search-input" type="search"
        aria-label="search" autocomplete="off" placeholder="搜索...">
    </span>
    <span id="search-cancel" >取消</span>
  </div>

</div>


    <div id="main-wrapper">
      <div id="main">

        









<div class="row">

  <!-- core -->
  <div id="core-wrapper" class="col-12 col-lg-11 col-xl-8">
    <div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4">

    

    
      
      
        <!--
  Refactor the HTML structure.
-->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Add attribute 'hide-bullet' to the checkbox list -->



<!-- images -->




  
  

  
    
      
      
    

    
    
    

    
    

    
    
    

    
      
      

      
      

      

      
    
      
      

      
      

      

      
    

    
      

      <!-- lazy-load images <https://github.com/ApoorvSaxena/lozad.js#usage> -->

      

    

    <!-- Add SVG placehoder to prevent layout reflow -->

    

    <!-- Bypass the HTML-proofer test -->
    

    

  

  



<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    

    

  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    

    

  

  
  

  

  
  

  




<!-- Wrap prompt element of blockquote with the <div> tag -->







<!-- return -->





<h1 data-toc-skip>DataStructure（02142）</h1>

<div class="post-meta text-muted">
    <!-- published date -->
    <span>
      发表于
      <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->





<em class=""
    data-ts="1648732795"
    data-df="YYYY-MM-DD"
    data-toggle="tooltip" data-placement="bottom">
  2022-03-31
</em>

    </span>

    <!-- lastmod date -->
    

  

  <div class="d-flex justify-content-between">
    <!-- author -->
    <span>
      
      

      

      作者

      <em>
        
          <a href="https://Cc360428.github.io/cc/">Cc</a>
        
      </em>
    </span>

    <div>
      <!-- page views -->
      

      <!-- read time -->
      <!--
  Calculate the post's reading time, and display the word count in tooltip
 -->



<!-- words per minute  -->










<!-- return element -->
<span class="readtime" data-toggle="tooltip" data-placement="bottom"
  title="10867 字">
  <em>60 分钟</em>阅读</span>

    </div>

  </div> <!-- .d-flex -->

</div> <!-- .post-meta -->

<div class="post-content">
  <h1 id="数据结构导论02142"><strong>数据结构导论（02142）</strong></h1>
<h2 id="第一章-概论重点"><span class="mr-2">第一章 概论（重点）</span><a href="#第一章-概论重点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="1-引言"><span class="mr-2">1 引言</span><a href="#1-引言" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>数据结构：是计算机组织数据和存储数据的方式</li>
  <li>计算机解决问题步骤
    <ol>
      <li>建立数学模型</li>
      <li>设计算法</li>
      <li>编程实现算法</li>
    </ol>
  </li>
  <li>程序=数据结构+算法</li>
  <li>通常操作：查找、读取、插入、删除、更新</li>
  <li>合理的数据结构有什么用
    <ol>
      <li>可降低程序设计的复杂性</li>
      <li>提高程序的执行效率</li>
    </ol>
  </li>
</ul>

<h3 id="2-基本概念和术语"><span class="mr-2">2 基本概念和术语</span><a href="#2-基本概念和术语" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>数据：所有被计算机存储、处理的的对象</li>
  <li>数据元素：是数据这个集合的一个个体积数据的<code class="language-plaintext highlighter-rouge">基本单位</code></li>
  <li>数据项：数据元素常常分为若干个数据项，是数据的具有意义的<code class="language-plaintext highlighter-rouge">最小单位</code>
    <blockquote>
      <p>数据-&gt;数据元素-&gt;数据项</p>
    </blockquote>
  </li>
  <li>逻辑结构：元素之间的结构关系（集合、线性、树形、图结构）
    <ul>
      <li>线性结构：除第一个和最后一个数据元素外，每个数据元素只有一个前驱和一个后继数据元素</li>
      <li>树结构：除根结点外，每个数据元素只有一个前驱数据元素，可有0个或若干个后继数据元素。</li>
      <li>图结构：每个数据元素可有0个或若干个前驱数据元素和0个或若干个后继数据元素。</li>
      <li>集合结构：数据元素同“属于一个集合”之间没有任何联系。</li>
    </ul>
  </li>
  <li>物理结构：存储结构（<code class="language-plaintext highlighter-rouge">顺序</code>、<code class="language-plaintext highlighter-rouge">链式</code>、索引、散列），数据在计算机内的表示称为<code class="language-plaintext highlighter-rouge">数据的存储结构</code>
    <ul>
      <li>存储结点</li>
      <li>数据元素之间关联方式的表示</li>
      <li>分类
        <ol>
          <li>顺序存储结构：借助数据元素的相对存储位置来表示数据的逻辑结构；
            <ol>
              <li>线性表的顺序存储方法：将表中的结点一次存放在计算机内存中<code class="language-plaintext highlighter-rouge">一组连续</code>的存储单元中。</li>
            </ol>
          </li>
          <li>链式存储结构：借助数据元素<code class="language-plaintext highlighter-rouge">地址的指针</code>表示数据的逻辑结构。</li>
          <li>索引存储结构：借助索引表中的<code class="language-plaintext highlighter-rouge">索引指示</code>各存储节点的存储位置。</li>
          <li>散列存储结构：用<code class="language-plaintext highlighter-rouge">散列函数</code>指示各节点的存储位置。</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>运算：在逻辑结构上施加的操作，逻辑结构加工</li>
  <li>加工型运算：操作改变原逻辑结构的值</li>
  <li>引用型运算：不改变原有逻辑结构的值（查找、读取、插入、删除、更新）
    <h3 id="算法及描述"><span class="mr-2">算法及描述</span><a href="#算法及描述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
  </li>
</ul>

<blockquote>
  <p>算法 规定了求解给定类型问题，所需的<code class="language-plaintext highlighter-rouge">所有 处理步骤</code> 及 <code class="language-plaintext highlighter-rouge">执行顺序</code> 是给定类型问题能在<code class="language-plaintext highlighter-rouge">有限时间</code>内被机械的求解</p>
</blockquote>

<ul>
  <li>算法特性（对特定问题求解步骤的描述，他是指令的有穷序列）
    <ol>
      <li>有穷性：在执行有穷步后结束</li>
      <li>确定性：每一步必须明确地定义</li>
      <li>可行性：每一步都可以同步已经实现的操作完成</li>
      <li>输入：可以零个或多个输入</li>
      <li>输出：一个或多个输出（特定关系的量）</li>
    </ol>
  </li>
</ul>

<h3 id="4-算法分析"><span class="mr-2">4 算法分析</span><a href="#4-算法分析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>算法设计满足
    <ul>
      <li>正确性：对于合法输入产生符合要求的输出</li>
      <li>可读性：易读、添加注释</li>
      <li>健壮性：非法输入是，能够作出反应而不会崩溃</li>
      <li>效率高切内存消耗小：运行时间短，储存制算法执行过程中所需的最大内存空间</li>
    </ul>
  </li>
  <li>算法<code class="language-plaintext highlighter-rouge">时空性</code>:时间复杂度、空间复杂度；目的提高算法的效率</li>
  <li>考虑两个度量分析
    <ul>
      <li>时间复杂度：运行时需要的总步数，通常时问题规模的函数（大O表示）
        <ul>
          <li>常数O(1)＜ 对数阶O(log2n) ＜ 线性阶O(n) ＜ 线性对数阶O(nlog2n) ＜ 平方阶O(n^2) ＜ 多项式阶O(n^C) ＜ 指数阶O(C^n)</li>
          <li>时间复杂度分析基本策略：从内向外分析，从最深层开始分析</li>
          <li>看有<code class="language-plaintext highlighter-rouge">几层循环</code>，一层循环是O(n)或者O(log2n)；两层循环是O(n^2) ；三层循环是O(n^3) （一般规律如此，具体问题具体分析）</li>
        </ul>
      </li>
      <li>空间复杂度：执行时所占用的储存空间，通常时问题规模的函数,运行过程中临时占用存储空间大小的度量
        <ul>
          <li>程序代码所占用的空间</li>
          <li>输入数据所占用的空间</li>
          <li><code class="language-plaintext highlighter-rouge">辅助变量</code>所占用的空间（估算时间复杂度，一般值分析辅助变量所占用的空间)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="5-小结"><span class="mr-2">5 小结</span><a href="#5-小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<h2 id="第二章-线性表重点"><span class="mr-2">第二章 线性表（重点）</span><a href="#第二章-线性表重点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<h3 id="1-线性表的基本概念"><span class="mr-2">1 线性表的基本概念</span><a href="#1-线性表的基本概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>线性表是有n(n&gt;=0)个数据元素（结点）组成的有限序列
    <ol>
      <li>n定义长度，n=0称为空表</li>
      <li>非空（n&gt;0）</li>
      <li>数据元素（1&lt;=i&lt;=n）</li>
      <li>1:1的关系</li>
    </ol>
  </li>
  <li>非空的线性表
    <ol>
      <li>有且仅有一个起始结点a1 ,没有直接前驱，有且仅有一个直接后继a2；</li>
      <li>有且仅有一个终端结点an，没有直接后继，有且仅有一个直接前驱an−1；</li>
      <li>其余的内部结点ai（2≤i≤n-1）都有且仅有一个直接前驱ai−1和一个直接后继ai+1</li>
    </ol>
  </li>
  <li>线性表的基本运算：初始化、求表长度、取表元、定位、插入、删除（区分引用和加工型操作）</li>
</ul>

<h3 id="2-线性表的顺序存储"><span class="mr-2">2 线性表的顺序存储</span><a href="#2-线性表的顺序存储" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>定义：顺序表是线性表的顺序存储结构，一段<code class="language-plaintext highlighter-rouge">连续</code>内存存放的线性表</li>
  <li>特点
    <ul>
      <li>顺序表是用<code class="language-plaintext highlighter-rouge">一维数组</code>实现线性表，数组下标是元素相对地址</li>
      <li>逻辑上相邻元素，在存储物理位置也是相邻的单元中</li>
      <li>线性表的逻辑结构与存储结构一致</li>
      <li>可以对数据元素实现随机读取</li>
    </ul>
  </li>
  <li>存储地址计算
    <ul>
      <li>每个结点类型相同、占用存储空间大小相同</li>
      <li>例如结点占用L个存储单元，其中第一个单元存储地址则是该结点的存储地址</li>
      <li>设表开始结点a1的存储地址d，结点ai的存储地址为<code class="language-plaintext highlighter-rouge">LOC(ai) </code> 公式：<code class="language-plaintext highlighter-rouge">LOC(ai) = d+(i−1)*L</code> <strong>（必考）</strong></li>
    </ul>
  </li>
  <li>顺序表插入运算
    <ul>
      <li>当表空间已满，不可在插入操作</li>
      <li>插入位置非法，不可正常插入操作</li>
      <li>插入新的结点x，插入位置i=n+1时，才无需移动结点，直接将x插入表的末尾</li>
      <li>长度变为 <code class="language-plaintext highlighter-rouge">n+1</code></li>
      <li>需要移动 <code class="language-plaintext highlighter-rouge">n-i+1</code></li>
      <li>元素平均移动次数 <code class="language-plaintext highlighter-rouge">n/2</code> 时间复杂度O(n)
        <div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>  <span class="kt">void</span> <span class="nf">InsertSeqList</span><span class="p">(</span> <span class="n">Seqlist</span> <span class="o">*</span><span class="n">L</span> <span class="n">DataType</span> <span class="n">x</span> <span class="kt">int</span> <span class="n">i</span> <span class="p">)</span>
  <span class="p">{</span>
  	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
  	<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span>
  		<span class="n">exit</span><span class="p">(</span> <span class="err">“</span> <span class="err">位置</span> <span class="err">错</span> <span class="err">误</span> <span class="err">”</span> <span class="p">);</span>
  	<span class="k">if</span> <span class="p">(</span> <span class="n">L</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">MaxSize</span> <span class="p">)</span>
  		<span class="n">exit</span> <span class="p">(</span><span class="err">“</span> <span class="err">溢出</span> <span class="s">");</span><span class="err">
</span><span class="s">     for( j=L.length-1; j&gt;=i; j--)</span><span class="err">
</span><span class="s">            L.data[ j ] = L.data[j-1 ];        //依次后移   L.data[ i-1] = x;</span><span class="err">
</span><span class="s">       L.length++;</span><span class="err">
</span><span class="s">  }</span><span class="err">
</span></pre></td></tr></tbody></table></code></div>        </div>
      </li>
    </ul>
  </li>
  <li>删除操作运算
    <ul>
      <li>只需要删除终端结点，无需移动结点</li>
      <li>长度-1</li>
      <li>需要移动<code class="language-plaintext highlighter-rouge">n-i+1</code></li>
      <li>元素平均移动次数 <code class="language-plaintext highlighter-rouge">n-1/2</code> 时间复杂度O(n)
  ```c
  void DeleteSeqList( SeqList *L, int i )
  {
  	int j;
  	  if ( i &lt; 1 || i &gt; L.length )
  		Error( “ 位置 错 误 ” );
  	for ( j = i; j &lt; L.length; j++ )
  		L.data[j - 1] = L.data[j];</li>
    </ul>

  	L.length–;
    <p>}
  ```</p>
  </li>
  <li>优点
    <ul>
      <li>无需表示该的单元的逻辑关系增加额外存储空间</li>
      <li>方便的随机取表任意结点</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>插入删除运算不方便，必须移动大大量的结点</li>
      <li>顺序表要求占用连续的存储空间，需要预先分配内存，表长变化较大是，难以确定合适储存规模</li>
    </ul>
  </li>
</ul>

<h3 id="3-线性表的链接存储"><span class="mr-2">3 线性表的链接存储</span><a href="#3-线性表的链接存储" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<blockquote>
  <p>线性表的链式存储值存储结构是链式的，常见的有（单链表、循环链表、双向链表）</p>
</blockquote>

<ul>
  <li>存储表示
    <ul>
      <li>用一组内衣的存储单元存放</li>
      <li>链表中结点的逻辑次序和物理次序不一定相同，必须存储指示后续结点地址信息</li>
      <li>date 数据域</li>
      <li>next 存放即诶单直接后继的地址（位置）的指针域（链域）</li>
      <li>NULL 空指针（^）</li>
      <li>head 头指针变量，存放链表中第一个结点地址</li>
    </ul>
  </li>
  <li>
    <div class="table-wrapper"><table>
      <tbody>
        <tr>
          <td>单链表：(Head</td>
          <td>exit)-&gt;(k</td>
          <td>^)</td>
        </tr>
      </tbody>
    </table></div>
    <ul>
      <li>插入运算（ai-1~ai）
        <ul>
          <li>找到ai-1（p） 存储x</li>
          <li>生成x</li>
          <li>p 指针域指向x，然后插入x</li>
          <li>x 结点指针域指向ai
            <div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>  <span class="kt">void</span> <span class="nf">InsertLinkList</span><span class="p">(</span> <span class="n">LinkList</span> <span class="n">head</span><span class="p">,</span> <span class="n">Data</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span> <span class="p">)</span>     <span class="cm">/* 在表中head的第i个数据元素结点之前插入一个以X为值的新结点。 */</span>
  <span class="p">{</span>
  	<span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
  	<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
  		<span class="n">q</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
  	<span class="k">else</span> <span class="n">q</span> <span class="o">=</span> <span class="n">GetLinkList</span><span class="p">(</span> <span class="n">head</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>            <span class="cm">/* 找第i-1个数据元素结点 */</span>
  	<span class="k">if</span> <span class="p">(</span> <span class="n">q</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>                                <span class="cm">/* 第i-1个结点不存在 */</span>
  		<span class="n">exit</span><span class="p">(</span> <span class="err">“</span> <span class="err">找到</span> <span class="err">插入位置</span> <span class="err">”</span> <span class="p">);</span>
  	<span class="k">else</span><span class="p">{</span> <span class="n">p</span>		<span class="o">=</span> <span class="n">malloc</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">)</span> <span class="p">);</span>       <span class="cm">/* 生成新结点 */</span>
  	      <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span>	<span class="o">=</span> <span class="n">x</span><span class="p">;</span>                            <span class="cm">/* 生成新结点指向X */</span>
  	      <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span>	<span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>                      <span class="cm">/* 新结点链域指向*q的后继结点 */</span>  <span class="mi">1</span>
  	      <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span>	<span class="o">=</span> <span class="n">p</span><span class="p">;</span>                            <span class="cm">/* 修改*q的链域 */</span>              <span class="mi">2</span>
  	<span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// 特别要注意：上面1和2二行代码不可颠倒顺序，否则*q链先断了会找不到。</span>
</pre></td></tr></tbody></table></code></div>            </div>
          </li>
        </ul>
      </li>
      <li>删除运算
        <ul>
          <li>找到i-1结点，存在继续，否则结束</li>
          <li>删除i结点，释放对应的内存
            <div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>  <span class="kt">void</span> <span class="nf">DeleteLinkList</span><span class="p">(</span> <span class="n">LinkList</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span> <span class="p">)</span>
  <span class="p">{</span>
  	<span class="n">Node</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
  	<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
  		<span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
  	<span class="k">else</span> <span class="n">p</span> <span class="o">=</span> <span class="n">GetLinkList</span><span class="p">(</span> <span class="n">head</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>    <span class="cm">/* 先找待删结点的直接前驱 */</span>
  	<span class="k">if</span> <span class="p">(</span> <span class="n">p</span> <span class="err">！</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
  	<span class="p">{</span>
  		<span class="n">q</span>	<span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>              <span class="cm">/* P指向待删结点 */</span>
  		<span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>              <span class="cm">/* 移出待删结点 */</span>
  		<span class="n">free</span><span class="p">(</span> <span class="n">q</span> <span class="p">);</span>                      <span class="cm">/* 释放已移出结点P的空间 */</span>
  	<span class="p">}</span>  <span class="k">else</span> <span class="n">printf</span><span class="p">(</span> <span class="err">”</span> <span class="n">error</span> <span class="err">”</span> <span class="p">);</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></div>            </div>
            <h3 id="45-其它运算在单链表的实现其他链表"><span class="mr-2">4、5 其它运算在单链表的实现、其他链表</span><a href="#45-其它运算在单链表的实现其他链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>单向循环链表：如果第一个结点指针域指向第一个结点构成循环，任意结点出发都能够扫描整个链表
    <ul>
      <li>普通链表的终端结点<code class="language-plaintext highlighter-rouge">next只为NULL</code></li>
      <li>循环链表终端结点<code class="language-plaintext highlighter-rouge">next指向头结点</code></li>
      <li><code class="language-plaintext highlighter-rouge">导致循环链表中结点只有一个指针</code></li>
    </ul>
  </li>
  <li>双向循环链表
    <ul>
      <li>链表中有两个指针域：一个指向后继结点、一个指向前驱结点（双向链表）</li>
      <li>
        <div class="table-wrapper"><table>
          <tbody>
            <tr>
              <td>(<code class="language-plaintext highlighter-rouge">Prior</code></td>
              <td><strong>date</strong></td>
              <td><code class="language-plaintext highlighter-rouge">next</code>)</td>
            </tr>
          </tbody>
        </table></div>
      </li>
      <li>头prior指向<code class="language-plaintext highlighter-rouge">最后一个结点</code>，最后一个结点next指<code class="language-plaintext highlighter-rouge">向头结点</code></li>
      <li>删除
        <div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>  <span class="n">q</span><span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prior</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
  <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div>        </div>
      </li>
      <li>插入
        <div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>  <span class="n">t</span><span class="o">-&gt;</span><span class="n">prior</span>	<span class="o">=</span> <span class="n">p</span><span class="p">;</span>
  <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span>		<span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prior</span>	<span class="o">=</span> <span class="n">t</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span>		<span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div>        </div>
        <h3 id="6-顺序实现与链式实现的比较"><span class="mr-2">6 顺序实现与链式实现的比较</span><a href="#6-顺序实现与链式实现的比较" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
      </li>
    </ul>
  </li>
</ul>

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th>时间复杂度</th>
      <th>顺序表</th>
      <th>链表</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>读</td>
      <td>O(1)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>找</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>插</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>删</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
  </tbody>
</table></div>

<p>存储密度 = 数据域占用存储量/整个存储结点占用存储量</p>

<ul>
  <li>顺序表
    <ul>
      <li>静态分配。程序执行之前必须明确规定存储规模。若线性表长度n变
化较大，则存诸规模难于预先确定估计过大将造成空间浪费，估计太小又将使空间溢出机会增多。</li>
      <li>为1。当线性表的长度变化不大，易于事先确定其大小时，为了节约存储空间，宜采用顺序表作为存储结构。</li>
      <li>随机存取结构，对表中任一结点都可在0（1）时间内直接取得线性表的操作主要是进行查找，很少做插入和删除操作时，采用顺序表做存储结构为宜。</li>
      <li>在顺序表中进行插入和删除，平均要移动表中近一半的结点，尤其是当每个结点的信息量较大时，移动结点的时间开销就相当可观</li>
    </ul>
  </li>
  <li>链表
    <ul>
      <li>动态分配只要内存空间尚有空闲，就不会产生溢出。因此，当线性表的长度变化较大，难以估计其存储规模时，以采用动态链表作为存储结构为好</li>
      <li>&lt;1</li>
      <li>顺序存取结构，链表中的结点，需从头指针起顺着链扫描才能取得。</li>
      <li>在链表中的任问位置上进行插入和删除，都只需要修改指针。对于频繁进行插入和删除的线性表，宜采用链表做存储结构。若表的插入和删除主要发生在表的首尾两端，则采用尾指针表示的单循环链表为宜</li>
    </ul>
  </li>
</ul>

<h3 id="7-小结"><span class="mr-2">7 小结</span><a href="#7-小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<h2 id="第三章-栈队列和数组重点"><span class="mr-2">第三章 栈、队列和数组（重点）</span><a href="#第三章-栈队列和数组重点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<blockquote>
  <p>栈和队列何以看作特殊的线性表</p>
</blockquote>

<h3 id="1-栈"><span class="mr-2">1 栈</span><a href="#1-栈" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>定义:栈只能在表一端(表尾)进行插入和删除的线性表
    <ul>
      <li>允许插入删除一端(尾部)称为<code class="language-plaintext highlighter-rouge">栈顶</code>(top),另一端表头称为<code class="language-plaintext highlighter-rouge">栈底</code>(bottom)</li>
      <li>表中没有元素称空栈</li>
    </ul>
  </li>
  <li>特点
    <ul>
      <li>进栈<code class="language-plaintext highlighter-rouge">push</code>;出栈<code class="language-plaintext highlighter-rouge">pop</code>删除</li>
      <li><strong>先进先出</strong> (LIFO)</li>
      <li>用途-常用于暂时保存待有处理的数据</li>
    </ul>
  </li>
  <li>顺序栈:是一组连续的存储单元一次放栈中的每个元素(初始端为栈低)
    <ul>
      <li>顺序实现</li>
    </ul>
  </li>
  <li>链式栈:链式存储,运算受限单链表,插入删除受限表头位置上进行栈顶指针就是链表的头指针</li>
</ul>

<h3 id="2-队列queue"><span class="mr-2">2 队列(Queue)</span><a href="#2-队列queue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>定义: 是一种运算受限的线性表,只允许一端插入在另一端删除
    <ul>
      <li>允许删除的一端为队头(front),允许插入的一端为队尾(rear)</li>
    </ul>
  </li>
  <li>特点
    <ul>
      <li><code class="language-plaintext highlighter-rouge">先进先出</code>(FIFO)</li>
      <li>用途-常用于暂时保存待有处理的数据</li>
    </ul>
  </li>
  <li>顺序实现:顺序存储,由一个一维数组(存储元素)
    <ul>
      <li>循环队列
        <ul>
          <li>上溢条件:sq.rear=-maxsize-1(队满)</li>
          <li>下溢条件:sq.rear==sq.front(队列空)</li>
          <li>假溢出:极端情况会出现上溢,为了客服假溢出引入<code class="language-plaintext highlighter-rouge">循环队列</code></li>
          <li>头尾连接</li>
          <li>插入:<code class="language-plaintext highlighter-rouge">rear=(sq.rear+1)%maxsize</code></li>
          <li>删除:<code class="language-plaintext highlighter-rouge">front=(sq.front+1)%maxsize</code></li>
          <li>下溢-队空:<code class="language-plaintext highlighter-rouge">CQ.front==CQ.rear</code></li>
          <li>上溢-队满:<code class="language-plaintext highlighter-rouge">(CQ.rear+1)%maxsize==CQ.front</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>链接实现
    <ul>
      <li>使用一个带有头结点的单链表来表示队列</li>
      <li>头结点exit域指向队列首结点,尾指针指向队列尾结点</li>
    </ul>
  </li>
</ul>

<h3 id="3-数组应用"><span class="mr-2">3 数组、应用</span><a href="#3-数组应用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<blockquote>
  <p>数组可以看成一种特殊的线性表,顺序存储,每一个元素值和一个下表组成,一般具有上界下界</p>
</blockquote>

<ul>
  <li>定义
    <ul>
      <li>一维内存单元连续(又称向量)</li>
      <li>二维存储方式两种
        <ul>
          <li>列序为主</li>
          <li>主序为主(C语言)</li>
        </ul>
      </li>
      <li>随机存取结构</li>
    </ul>
  </li>
  <li>读写:给一定下标读取和修改元素</li>
  <li>矩阵的压缩存储
    <ul>
      <li>矩阵是一种常用的数据对象,来描述一个二维数组</li>
      <li>矩阵存储下进行元素随机存储</li>
      <li>存储密度为1</li>
      <li>矩阵中零元素存在大量的零元素,队矩阵造成极大的浪费,为了节省空间,对矩阵进行<code class="language-plaintext highlighter-rouge">压缩存储</code></li>
      <li>压缩存储:即多个相同元素的非零只分配一个存储空间,对零元素不分配空间</li>
      <li>特殊矩阵压缩分类
        <ul>
          <li>对称矩阵</li>
          <li>三角矩阵(上三角、下三角)</li>
        </ul>
      </li>
      <li>稀疏矩阵
        <h3 id="4-小结"><span class="mr-2">4 小结</span><a href="#4-小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
        <h2 id="第四章树和二叉树重难点"><span class="mr-2">第四章树和二叉树（重、难点）</span><a href="#第四章树和二叉树重难点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
      </li>
    </ul>
  </li>
  <li>非线性结构</li>
  <li>1:N关系
    <h3 id="1-树的基本概念"><span class="mr-2">1 树的基本概念</span><a href="#1-树的基本概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
  </li>
  <li>概念
    <ul>
      <li>定义:是n(n&gt;=0)个结点有限集</li>
      <li>有且仅有一个特定的称为根结点</li>
      <li>其余结点可分为m(m&gt;=0)个互相不交集的子集,其中每个子集有是一颗书,并称其为子树</li>
      <li><code class="language-plaintext highlighter-rouge">递归是树的固有特性</code></li>
      <li>逻辑表示
        <ul>
          <li>直观表示</li>
          <li>嵌套括号法</li>
          <li>凹入表示法</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>相关术语
    <ul>
      <li>结点:由一个元素及若干个指向其他结点的分支所组成</li>
      <li>度
        <ul>
          <li>结点的度:该结点子树数(分支)</li>
          <li>树的度:树中结点的度最大值</li>
        </ul>
      </li>
      <li>叶子(终端结点):度为零的结点</li>
      <li>非终端结点:度不为零的结点</li>
      <li>结点层次:从根开始算起,根为第一层</li>
      <li>树的高度:所有结点层次树的最大值称该树的高度或深度</li>
      <li>有序树:左右不能互换,有次序,最左子树的根称第一个孩子</li>
      <li>无序树:各个结点的子树是无序的,可以互换</li>
      <li>森林:m(&gt;=0)课树的集合</li>
      <li>结点和边的关系:n个结点的树,共有n-1条边</li>
    </ul>
  </li>
</ul>

<h3 id="2-二叉树"><span class="mr-2">2 二叉树</span><a href="#2-二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<blockquote>
  <p>任何一棵树都可以与二叉树相互转换</p>
</blockquote>

<ul>
  <li>定义
    <ul>
      <li>二叉树是n（n&gt;=0）个结点有限集合，或空（n=0）</li>
      <li>每课子树都是二叉树</li>
    </ul>
  </li>
  <li>特点
    <ul>
      <li>二叉树可以是空，称空二叉树</li>
      <li>每个结点最多是两个孩子</li>
      <li>子树有左，右，之分次序不能颠倒</li>
    </ul>
  </li>
  <li>与树的比较</li>
</ul>

<p>|  | 结点 | 子树 | 结点顺序 |
| — | — | — | — |
| 树 | n&gt;=0 | 不定（有限） | 无 |
| 二叉树 | n&gt;=0 | &lt;=2 | 有（左、右） |</p>
<ul>
  <li>二叉树的性质
    <ul>
      <li>在二叉树的第i(i&gt;=1)层上至多有2i-1个结点。（i&gt;=1）；至少1个</li>
      <li>深度为k(k&gt;=1)的二叉树至多有2k－1个结点；至少K个</li>
      <li>对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0＝n2＋1。即：叶结点数n0=度为2的结点数n2+1</li>
      <li>下图其中度为2的结点数共有5个，即ABCEF（有2个孩子的，如G就不是），叶子共有6个，即IJKLMH(没有结点，度为0的)，得出这二叉树终端结点数=度为2的结点数+1，即6=5+1
        <pre><code class="language-mermaid">  graph TB;
  A((A))
  B((B))
  C((C))
  E((E))
  F((F))
  G((G))
  H((H))
  I((I))
  J((J))
  K((K))
  L((L))
  M((M))
  A--&gt;B
  A--&gt;C
  B--&gt;E
  B--&gt;F
  E--&gt;I
  E--&gt;J
  C--&gt;G
  G--&gt;M
  F--&gt;K
  F--&gt;L
  C--&gt;H
</code></pre>
      </li>
      <li>满二叉树:深度为k(k&gt;=1)且有<code class="language-plaintext highlighter-rouge">2^k-1</code>个结点的二叉树；下图满二叉树结点 2^3-1=7
        <pre><code class="language-mermaid">  graph TB;
  1((1))
  2((2))
  3((3))
  4((4))
  5((5))
  6((6))
  7((7))
  1--&gt;2
  1--&gt;3
  2--&gt;4
  2--&gt;5
  3--&gt;6
  3--&gt;7
</code></pre>
      </li>
      <li>完全二叉树:深度为K的二叉树中，K-1层结点数是满的(2k-2 )，K层结点是左连续的(即结点编号是连续的)</li>
      <li><strong>满二叉树一定是完全二叉树，而完全二叉树不一定是满二叉树过</strong></li>
    </ul>
  </li>
</ul>

<h3 id="3-二叉树的存储结构"><span class="mr-2">3 二叉树的存储结构</span><a href="#3-二叉树的存储结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>顺序存储
    <ul>
      <li>一组连续的存储单元存储</li>
      <li>必须把二叉树所有结点安排一个恰当的序列</li>
      <li>对二叉树进行编号，然后用一维数组存储，其中编号为i的结点存储在数组中的下标为i对的分量中–称为<code class="language-plaintext highlighter-rouge">一编号为地址</code>策略</li>
      <li>树从根起，自上层至下层，每层子左至右给所有结点编号
        <ul>
          <li>缺点对存储空间造成极大的浪费（深度为H且只有H个结点右单只树需要2^h-1个结点存储空间）</li>
          <li>若经常需要插入删除树中结点是，顺序方式不是很好</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>链式存储
    <ul>
      <li>画二叉链</li>
    </ul>
  </li>
</ul>

<h3 id="4-二叉树的遍历"><span class="mr-2">4 二叉树的遍历</span><a href="#4-二叉树的遍历" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>遍历二叉树：是按照一定规律对二叉树中每个结点访问且仅访问一次</li>
  <li>D-根；L-左；R-右</li>
  <li>遍历分类
    <ul>
      <li>先序遍历(DLR)-根左右 <strong>A-&gt;B-&gt;D-&gt;H-&gt;E-&gt;I-&gt;C-&gt;F-&gt;J-&gt;K-&gt;G</strong>
        <div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>  <span class="kt">void</span>   <span class="nf">preorder</span><span class="p">(</span> <span class="n">bitreptr</span> <span class="n">r</span> <span class="p">)</span>
  <span class="p">{</span>
  	<span class="cm">/*先序遍历以r为根的二叉树*/</span>
  	<span class="k">if</span> <span class="p">(</span> <span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
  		<span class="k">return</span><span class="p">;</span>
  	<span class="n">printf</span><span class="p">(</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">data</span> <span class="p">);</span>         <span class="cm">/*访问根结点*/</span>
  	<span class="n">preorder</span><span class="p">(</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="p">)</span> <span class="err">；</span>
  	<span class="n">preorder</span><span class="p">(</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="p">);</span>
  	<span class="cm">/*先序遍历以r的右孩子为根的右子树*/</span>
  <span class="p">};</span>
</pre></td></tr></tbody></table></code></div>        </div>
      </li>
      <li>中序遍历(LDR)-左根右 <strong>D-&gt;H-&gt;B-&gt;E-&gt;I-&gt;A-&gt;J-&gt;F-&gt;K-&gt;C-&gt;G</strong>
        <div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>  <span class="kt">void</span>   <span class="nf">inorder</span><span class="p">(</span> <span class="n">bitreptr</span> <span class="n">r</span> <span class="p">)</span>
  <span class="p">{</span>
  	<span class="cm">/*中序遍历以r为根的二叉树*/</span>
  	<span class="k">if</span> <span class="p">(</span> <span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
  		<span class="k">return</span><span class="p">;</span>
  	<span class="n">inorder</span><span class="p">(</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="p">)</span> <span class="err">；</span>
  	<span class="cm">/*中序遍历以r的左孩子为根的左子树*/</span>
  	<span class="n">printf</span><span class="p">(</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">data</span> <span class="p">);</span>              <span class="cm">/*访问根结点*/</span>
  	<span class="n">inorder</span><span class="p">(</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="p">);</span>           <span class="cm">/*…….*/</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></div>        </div>
      </li>
      <li>后序遍历(LRD)-左右根 <strong>H-&gt;D-&gt;I-&gt;E-&gt;B-&gt;J-&gt;K-&gt;F-&gt;G-&gt;C-&gt;A</strong>
        <div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>  <span class="kt">void</span>   <span class="nf">postorder</span><span class="p">(</span> <span class="n">bitreptr</span> <span class="n">r</span> <span class="p">)</span>
  <span class="p">{</span>
  	<span class="cm">/*后序遍历以r为根的二叉树*/</span>
  	<span class="k">if</span> <span class="p">(</span> <span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
  		<span class="k">return</span><span class="p">;</span>
  	<span class="n">postorder</span><span class="p">(</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="p">)</span> <span class="err">；</span>
  	<span class="cm">/*后序遍历以r的左孩子为根的左子树*/</span>
  	<span class="n">postorder</span><span class="p">(</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="p">)</span> <span class="err">；</span>
  	<span class="n">printf</span><span class="p">(</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">data</span> <span class="p">);</span>       <span class="cm">/*访问根结点*/</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></div>        </div>
        <pre><code class="language-mermaid">  graph TB;
  A((A))
  B((B))
  C((C))
  D((D))
  E((E))
  F((F))
  G((G))
  H((H))
  I((I))
  J((J))
  K((K))
  nil((nil))
  nille((nille))
  A--&gt;B
  A--&gt;C
  B--&gt;D
  B--&gt;E
  E--&gt;nille
  E--&gt;I
  D--&gt;nil
  D--&gt;H
  C--&gt;G
  C--&gt;F
  F--&gt;J
  F--&gt;K
</code></pre>
        <h3 id="5-树和森林"><span class="mr-2">5 树和森林</span><a href="#5-树和森林" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
      </li>
    </ul>
  </li>
  <li>树的存储结构
    <ul>
      <li>
        <div class="table-wrapper"><table>
          <tbody>
            <tr>
              <td>孩子链表表示法：（<code class="language-plaintext highlighter-rouge">child</code></td>
              <td><code class="language-plaintext highlighter-rouge">next</code>）</td>
            </tr>
          </tbody>
        </table></div>
        <ul>
          <li>child：存放孩子结点在表头数组中的序号</li>
          <li>exit：指向下一个孩子结点</li>
        </ul>
      </li>
      <li>
        <div class="table-wrapper"><table>
          <tbody>
            <tr>
              <td>孩子兄弟链表示法（二叉链表表示）（<code class="language-plaintext highlighter-rouge">son</code></td>
              <td><strong>data</strong></td>
              <td><code class="language-plaintext highlighter-rouge">brother</code>）</td>
            </tr>
          </tbody>
        </table></div>
        <ul>
          <li>son：指向第一个孩子结点</li>
          <li>brother：指向该结点的下一个兄弟结点</li>
        </ul>
      </li>
      <li>双亲表示法</li>
    </ul>
  </li>
  <li>树、森林、二叉树
    <ul>
      <li>树-&gt;二叉树
        <ul>
          <li>各兄弟之间加连线</li>
          <li>对任一结点，除最左孩子，抹掉该结点与其余孩子的各枝</li>
          <li>以根为轴心，将连线顺指针转45度</li>
        </ul>
      </li>
      <li>森林-&gt;二叉树
        <ul>
          <li>将每棵树转换成相应的二叉树</li>
          <li>将（1）中得到的各颗二叉树的根结点看做是兄弟链接起来</li>
        </ul>
      </li>
      <li>二叉树-&gt;一般树
        <ul>
          <li>从根结点起</li>
          <li>该结点左孩子和左孩子右枝上的结点一次作为该结点孩子</li>
          <li>重复（1）</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>树和森的遍历
    <ul>
      <li>树
        <ul>
          <li>先序遍历：先序先访问根结点，然后一次先序遍历根的每<strong>A-&gt;B-&gt;C-&gt;D-&gt;E</strong></li>
          <li>后序遍历：先依次后续遍历每棵子树，最后访问根结点<strong>B-&gt;D-&gt;C-&gt;E-&gt;A</strong></li>
          <li>层次遍历：遍历每个兄弟结点<strong>A-&gt;B-&gt;C-&gt;E-&gt;D</strong>
            <pre><code class="language-mermaid">  graph TB;
  A((A))
  B((B))
  C((C))
  D((D))
  E((E))
  A--&gt;B
  A--&gt;C
  A--&gt;E
  C--&gt;D
</code></pre>
          </li>
        </ul>
      </li>
      <li>森林的遍历
        <ul>
          <li>先序：访问森林中每棵树的根结点；先序遍历森林中第一棵树的根结点的子树组成的森林；先序遍历除去第一棵树之外其余的树组成的森林。</li>
          <li>中序：中序访问森林中第一棵树的根结点的子树组成的森林；访问第一棵树的根结点；中序遍历除去第一棵树之外其余的树组成的森林；</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="6-判定树和哈夫曼树"><span class="mr-2">6 判定树和哈夫曼树</span><a href="#6-判定树和哈夫曼树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>解题思路：先求哈夫曼树，再求哈夫曼编码
    <ul>
      <li>求哈夫曼树的口诀
        <ol>
          <li>构造森林全是根</li>
          <li>选用两小造新树</li>
          <li>删除两小添新人</li>
          <li>重复，2，3剩单根
            <h3 id="7-小结-1"><span class="mr-2">7 小结</span><a href="#7-小结-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
            <h2 id="第五章-图重点"><span class="mr-2">第五章 图（重点）</span><a href="#第五章-图重点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
            <blockquote>
              <p><strong>邻接矩阵</strong> 、<strong>邻接表</strong>存储结构；<strong>深度优先</strong>和<strong>广度优先</strong>；<strong>求最小生成树的prim算法</strong></p>
            </blockquote>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h3 id="1-图的基本概念"><span class="mr-2">1 图的基本概念</span><a href="#1-图的基本概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>图的定义
    <ul>
      <li>图G：是有集合V合成E组成，记成G=(V,E)
        <ul>
          <li>v：顶点集（非空）</li>
          <li>E：边集（可空），可只有顶点，没边</li>
        </ul>
      </li>
      <li>边是顶点的有序对或无序对（反映两点之间的关系）
        <ul>
          <li>有向图：边顶点有序对的图（用箭头指明方向）</li>
          <li>无向同：边是顶点的无序对的图</li>
        </ul>
      </li>
      <li>网状结构（比线性（线性表）、层次（图））更复杂</li>
      <li>多对多(<strong>N:N</strong>)</li>
      <li>集合可空</li>
      <li>边集中不允许出现相同的边</li>
    </ul>
  </li>
  <li>基本术语
    <ul>
      <li>顶点：图中的数据元素</li>
      <li>弧头（终端点）箭头端</li>
      <li>弧尾（初始点）无箭头端</li>
      <li>完全图
        <ul>
          <li>无向完全图：边数=<code class="language-plaintext highlighter-rouge">n*(n-1)/2</code>的无向图</li>
          <li>有向完全图：边数=<code class="language-plaintext highlighter-rouge">n*(n-1)</code>的有向图</li>
        </ul>
      </li>
      <li>权：与图中的边相关的数</li>
      <li>子图：图G和G′,若有V(G′)∈=V(G)和 E(G′)∈= E(G),则称 G′为图G的子图</li>
      <li>邻接：若(Vi,Vj)∈E(G)，则称Vi和Vj互为邻接点</li>
      <li>关联：若(Vi,Vj)∈E(G)，则称边(Vi,Vj)关联于顶点Vi和Vj;</li>
      <li>度
        <ul>
          <li>无向图：顶点Vi的度为与Vi相关联的边的个数；D(Vi)用<code class="language-plaintext highlighter-rouge">（ ）</code>表示</li>
          <li>有向图用<code class="language-plaintext highlighter-rouge">&lt; &gt;</code>表示
            <ul>
              <li>出度：顶点Vi的出度为以Vi为尾的出边数</li>
              <li>入度：顶点Vi的入度为以Vi为头的入边数</li>
              <li>度：有向图的度=入度+出度</li>
            </ul>
          </li>
          <li>一边带二度，两度组一边</li>
        </ul>
      </li>
      <li>路径</li>
      <li>路径长度：路径上边或弧的数目</li>
      <li>简单路径：除第一个和最后一个外，其余的各个顶点均不相同的路径</li>
      <li>回路：第一个和最后一个顶点相同的路径（也称环）</li>
      <li>简单回路：第一个和最后一个顶点相同的简单路径
        <blockquote>
          <p>回路中可以有多个圈，而简单回路只能有一个圈</p>
        </blockquote>
      </li>
      <li>连通：无向图中，若从顶点Vi到Vj顶点有路径，则称Vi和Vj是连通的</li>
      <li>连通图和连同分量</li>
      <li>生成树：含有该连通图的全部顶点的一个极小连通子图。若连通图G的顶点个数为n，则G的生成树的变数为n-1
        <ul>
          <li>边&gt;n-1，一定有环</li>
          <li>边&lt;n-1，一定不连同</li>
        </ul>
      </li>
      <li>生成森林：在非连通图中，每个连通分量都可得到一个极小连通子图，也就是生成树。这些生成树就组成了一个非连通图的生成森林。</li>
      <li>基本运算
        <ul>
          <li>建立图GreateGraph(G,V,E)</li>
          <li>取顶点信息Getvex(G,u)</li>
          <li>取边信息Getarc(G,u,v)</li>
          <li>查询第一个邻接点FirstVex(G,u)</li>
          <li>查询下一个邻接点NextVex(G,u,v)</li>
          <li>插入顶点InsertVex(G,v)</li>
          <li>删除顶点DeleteVex(G,v)</li>
          <li>插入边InsertArc(G,v,w)</li>
          <li>删除边DeleteArc(G,v,w)</li>
          <li><strong>遍历图Travers(G,tag)</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="2-图的存储结构"><span class="mr-2">2 图的存储结构</span><a href="#2-图的存储结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<blockquote>
  <p>没有顺序存储结构，可以借助二维数组表示，也叫做邻接矩阵；共有邻接矩阵，邻接表，十字链表，邻接多重等存储结构….</p>
</blockquote>

<ul>
  <li>邻接矩阵表示法（也叫二维数组）
    <ul>
      <li>图的邻接矩阵：表示图的各顶点之间关系的矩阵
        <ol>
          <li>有边1表示</li>
          <li>无边0表示
            <ul>
              <li>无向图的邻接矩阵是对称的</li>
              <li>从邻接矩阵容易判断任意两顶点间是否有边相联；容易求出各顶点的度</li>
              <li>无向图：顶点Vi的度D(Vi)=矩阵中第i行的1总和</li>
              <li>有向图：OD(Vi)=矩阵中第i行的1总和，I D(Vi)=矩阵中第i列的1总和</li>
            </ul>
          </li>
        </ol>
      </li>
      <li>带权图(网)的邻接矩阵
        <ul>
          <li>有n个结点，对应就会有n*n的方阵</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>邻接表示法（连式）
    <ul>
      <li>n个顶点、e条边的无向图，则其邻接表的表头结点数为n，链表结点总数为2e；</li>
      <li>对于无向图，第i个链表的结点数为顶点Vi的度；</li>
      <li>对于有向图，第i个链表的结点数为顶点Vi的出度；</li>
      <li>在边稀疏时，邻接表比邻接矩阵省单元；</li>
      <li>邻接表表示在检测边数方面比邻接矩阵表示效率要高。</li>
    </ul>
  </li>
</ul>

<h3 id="3-图的遍历"><span class="mr-2">3 图的遍历</span><a href="#3-图的遍历" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<blockquote>
  <p>从图G的某一顶点V出发，顺序访问各顶点一次</p>
</blockquote>

<ul>
  <li>
    <p>方法：为了克服顶点的重复访问，设立辅助数组（visited[n]）</p>

    <pre><code class="language-math">  visted[i]=\left\{
  \begin{aligned}
  1=&amp;顶点i已被访问过 \\
  0=&amp;顶点i未被访问过\\
  \end{aligned}
  \right.
</code></pre>
  </li>
  <li>
    <p>遍历分类</p>
    <ul>
      <li>深度优先搜索发（DFS）<strong>必考</strong>
  <img data-src="https://gitee.com/hyperli0612/images/raw/master/SelfStudy/DataStructur/5.3.png" alt="Go" data-proofer-ignore>
        <ul>
          <li>为克服顶点的重复访问，设立一标识向量 visited[n]</li>
          <li>图可用邻接矩阵或邻接表表示</li>
          <li>DFS规则具有递归性，故需用到<code class="language-plaintext highlighter-rouge">栈</code></li>
          <li>搜索到达某个顶点时(图中仍有顶点未被访问)，如果这个顶点的所有邻接点都被访问过，那么搜索就要回到前一个被访问过的顶点，再从该顶点的下一未被访问的邻接点开始深度优先搜索。</li>
          <li>深度搜索的顶点的访问序列<code class="language-plaintext highlighter-rouge">不是唯一的</code></li>
        </ul>
      </li>
      <li>广度优先搜索发（BFS）**考点
        <ul>
          <li>类似于树的层次遍历的过程（遍历所有的兄弟结点）</li>
          <li>过程：中某一点Vi出发，首先访问Vi的所有邻接点（w1，w2，…，wt），然后再顺序访问w1，w2，…，wt的 所有未被访问过的邻接点…., 此过程直到所有顶点都被访问过</li>
          <li>图可用邻接矩阵或邻接表表示</li>
          <li>顶点的处理次序——先进先出，故需用到<code class="language-plaintext highlighter-rouge">队列</code></li>
          <li>思想
            <ol>
              <li>所有结点标记置为“未被访问”标志；</li>
              <li>访问起始顶点，同时置起始顶点“已访问”标记；</li>
              <li>将起始顶点进队列</li>
              <li>当队列不为空时重复执行以下步骤；
                <ol>
                  <li>取当前队头顶点；</li>
                  <li>对与队头顶点相邻接的所有未被访问过的顶点依次做：
                    <ol>
                      <li>访问该顶点</li>
                      <li>置该顶点为“已访问”标记,并将它进队列；</li>
                    </ol>
                  </li>
                  <li>当前队头元素顶点出队；</li>
                  <li>重复进行，直到队空时结束。</li>
                </ol>
              </li>
            </ol>
          </li>
        </ul>
      </li>
      <li>求图的连通分量
        <ul>
          <li>判断连通性：调用一次DFS或BFS得到一顶点集合之后与V(G)比较，若两集合相等，则图G是连通图，否则不连通</li>
          <li>求图的连通分量：图遍历的一种应用</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="4-图的应用"><span class="mr-2">4 图的应用</span><a href="#4-图的应用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>最小生成树：连通图G=(V,E)，从任一顶点遍历，则图中边分成两部分：<code class="language-plaintext highlighter-rouge">E(G) = T(G)+ B(G)</code>
    <ul>
      <li>T(G):遍历通过的边</li>
      <li>B(G):剩下的边（即遍历时未通过的边）</li>
    </ul>
  </li>
  <li>深度优先生成树：按照深度优先遍历而生成的树</li>
  <li>广度优先生成树：按照广度优先遍历而生成的树</li>
  <li>图的生成树不是唯一的</li>
  <li>最小生成树也不是唯一的</li>
  <li>最小生成树：给一个带权图，构造带权图的一颗生成树，使树中所有边权总和为最小</li>
  <li>最小生成树的构造算法
    <ul>
      <li>Prim算法：适用于稠密最小生成树</li>
      <li>Kruskal算法：构造的最小生成树不唯一，但权和相同，适合与求边稀疏的网的最小生成树</li>
    </ul>
  </li>
  <li>拓扑排序：拓扑有序序列的构造过程称
    <ul>
      <li>AOV网：对AOV网构造顶点线性序列（…i,…,k,…j,…）i是j的前趋，则i在j之前，若i、k间无路径，则或i在k前，或k在i前。这样的线性序列称为拓扑有序序列</li>
      <li>拓扑排序算法：避免重复查找，可将入度为0的顶点入度域串链成一个链式栈
        <ul>
          <li>将全体入度为0 的顶点入栈；</li>
          <li>链栈非空时，反复执行：
            <ul>
              <li>弹出栈顶元素Vj并将其输出；</li>
              <li>检查Vj的出边表，将每条出边（Vj，Vk）的终点Vk的入度域减1；</li>
              <li>若Vk的入度为0，则Vk入栈。</li>
            </ul>
          </li>
          <li>若输出的顶点数小于N，则输出有回路；否则，拓扑排序结束。</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="5-小结-1"><span class="mr-2">5 小结</span><a href="#5-小结-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<h2 id="第六章查找"><span class="mr-2">第六章查找</span><a href="#第六章查找" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="1-基本概念"><span class="mr-2">1 基本概念</span><a href="#1-基本概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>查找表：是由同一类型的数据元素构成的集合，查找中的核心</li>
  <li>查找：给定K值，寻找K的数据元素</li>
  <li>静态查找表：进行的是引用型运算
    <ul>
      <li>基本运算
        <ul>
          <li>建表</li>
          <li>查找</li>
          <li>读表中元素</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>动态查找表：进行的是加工型运算
    <ul>
      <li>基本运算
        <ul>
          <li>初始化</li>
          <li>查找</li>
          <li>读表中元素</li>
          <li>插入</li>
          <li>删除</li>
        </ul>
      </li>
      <li>树查找（二分查找，B树查找）</li>
      <li>哈希查找</li>
    </ul>
  </li>
  <li>查找成功：在数据元素集合中找到了要查找的数据元素</li>
  <li>查找不成功：在数据元素集合中没有找到要查找的数据元素
    <h3 id="2-静态查找表"><span class="mr-2">2 静态查找表</span><a href="#2-静态查找表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
  </li>
  <li>二分法查找
    <ul>
      <li>静态查找：二分查找，索引顺序表查找</li>
      <li>动态查找：二叉排序树找，哈希查找</li>
    </ul>
  </li>
  <li>顺序表中查找：二分法查找法
    <ul>
      <li>从表中最后一个记录开始顺序进行查找，若当前记录的关键字=给定值，则查找成功；否则，继续查上一记录…；若直至第一个记录尚未找到需要的记录，则查找失败。包括“二分查找，索引顺序表查找”二种方法</li>
      <li>优点：简单，对表无要求</li>
      <li>缺点：比较次数多</li>
      <li>算法
        <ul>
          <li>设立岗哨</li>
        </ul>
      </li>
      <li>思想：：每次将处于查找区间中间位置上的数据元素与给定值K比较，若不等则缩小查找区间并在新的区间内重复上述过程，直到查找成功或查找区间长度为0（查找不成功）为止。<code class="language-plaintext highlighter-rouge">可使下次查找范围缩小一半</code></li>
    </ul>
  </li>
  <li>分块查找：索引顺序查找
    <ul>
      <li>查找过程（把数据分为若干个块，然后在块中再查找）
        <ul>
          <li>先建立最大（小）关键字表-索引表（有序）</li>
          <li>查找索引表，以确定所查找元素块号</li>
          <li>在相应的块中按顺序查找关键字为K的记录</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="3-二叉排序树"><span class="mr-2">3 二叉排序树</span><a href="#3-二叉排序树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>定义：是种特殊的、增加了限制条件的二叉树</li>
  <li>条件
    <ul>
      <li>左子树上所有结点的值都小于它的根值，如左子树为空除外。</li>
      <li>右子树上所有结点的值都大于它的根植，如右子树为空除外</li>
      <li>每一个子树也要分别满足上二个条件，即一层一层都是这样条件</li>
    </ul>
  </li>
  <li>总结：二叉排序树上进行查找，如查找成功，则是从根结点出发走了一条从根结点到待查结点的路径；如查找不成功，则是从根结点出发走了一条从根到某个叶子的路径。因些与二分查找类似，关键字比较的次数不超过二叉树的深度，对于同一组结点，由于建立二叉排序树时插入结点的先后次序不同，所构成的二叉排序树的形态与深度也不同，含有n个结点的二叉排序树不是唯一的。也就是说，二叉排序树上的查找长度不仅与结点数n有关，也与二叉排序树的生成过程有关</li>
  <li>插入原则：必须要保证插入一个新结点后，仍为一棵二叉排序树，这个结点是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子
    <h3 id="4-散列表"><span class="mr-2">4 散列表</span><a href="#4-散列表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
  </li>
  <li>哈希表
    <ul>
      <li>散列函数（哈希函数）：关键字与元素地址的函数</li>
      <li>散列地址：由散列函数决定数据元素的存储位置，该位置称为散列地址</li>
      <li>散列查找：关键字-&gt;散列函数转换-&gt;位置上有无元素</li>
      <li>散列表：通过散列法建立的表称为散列表</li>
    </ul>
  </li>
  <li>冲突
    <ul>
      <li>散列表的实现：链池址法</li>
      <li>优点：直接由关键字通过哈希函数计算出哈希地址，查找效率高</li>
      <li>缺点：常发生冲突，影响查找效率</li>
    </ul>
  </li>
</ul>

<h3 id="5-小结-2"><span class="mr-2">5 小结</span><a href="#5-小结-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<h2 id="第七章排序重点"><span class="mr-2">第七章排序（重点）</span><a href="#第七章排序重点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<h3 id="1-概述"><span class="mr-2">1 概述</span><a href="#1-概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>数据排序：一个文件记录按照关键字不减（不增）次序排列，是文件成为有序的文件，此过程称为排序</li>
  <li>稳定排序：若排序后相同的关键字的记录保持原来相对次序</li>
  <li>不稳定排序：反之稳定排序</li>
  <li>排序类型
    <ul>
      <li>内部排序：全部数据存与内存 <strong>只考</strong>
        <ul>
          <li>插入排序：又分直接插入排序，折半插入（二分法）排序，表插入和希尔排序几种，我们重点掌握<code class="language-plaintext highlighter-rouge">直接插入排序</code>就可</li>
          <li>交换排序：又分<code class="language-plaintext highlighter-rouge">冒泡排序，快速排序</code></li>
          <li>选择排序：又分<code class="language-plaintext highlighter-rouge">直接选择排序</code>，堆排序</li>
          <li>并归排序：它和和前几种完全不同的排序，它又分为有序序列合并，<code class="language-plaintext highlighter-rouge">二路归并</code>排序</li>
        </ul>
      </li>
      <li>外部排序：需要对外存进行访问的排序过程</li>
    </ul>
  </li>
</ul>

<h3 id="2-插入排序"><span class="mr-2">2 插入排序</span><a href="#2-插入排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>过程：对R_1，…，R_i−1已排好序，有K_1≤K_2≤….≤K_i−1，现将K_i依次与K_i−1，K_i−2，…进行比较，并移动元素，直到发现R_i应插在R_j与R_j+1之间(即有K_j ≤ K_i＜K_j+1 )，则将R_i插到j+1号位置上，形成i个有序序列。（i从2～n）</li>
  <li>算法
    <ul>
      <li>存储空间 n+1；（1为附加空间）</li>
      <li>时间复杂度 O(n^2)</li>
      <li>稳定性：稳定排序
  ```c
  void straightsort( list r );
  {                                               /* 用直接插入排序法对r[1]…r[n]进行排序 <em>/
  	for ( i = 2; i &lt;= n; i++ )                    /</em> n为表长，从第二个记录进行插入 <em>/
  	{
  		r[0]	= r[i];                         /</em> 第i个记录复制为岗哨 <em>/
  		j	= i - 1;
  		while ( r[0].key &lt; r[j].key )            /</em> 与岗哨比较，直到健不大于岗哨键值 <em>/
  		{
  			r[j + 1]	= r[j];                 /</em> 将第j个记录赋值给第j+1个记录 <em>/
  			j		= j - 1;
  		}
  		r[j + 1] = r[0];                       /</em> 将第i个记录插入到序列中 */
  	}
  }</li>
    </ul>

    <p>```</p>
    <h3 id="3-交换排序"><span class="mr-2">3 交换排序</span><a href="#3-交换排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
  </li>
  <li>冒泡排序
    <ul>
      <li>基本思想：通过多次重复比较、交换相邻记录而实现排序；每一趟的效果都是将当前键值最大的记录换到最后。它是对n个元素排序，所历经的<strong>趟数至少为1，至多为n-1</strong></li>
      <li>原理：通过两两数进行多次对比，把最大的数放在最后面，如下面多次比较才得到第一趟结果把49放在最后面，这就是冒泡的原理(<code class="language-plaintext highlighter-rouge">21，25，49，25，16，08</code>)
        <div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>  第一趟：21，25，25，16，08，49
  第二趟：21，25，16，08，25，49
  第三趟：21，16，08，25，25，49
  第四趟：16，08，21，25，25，49
  第五趟：08，16，21，25，25，49
</pre></td></tr></tbody></table></code></div>        </div>
        <div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>  <span class="n">Void</span> <span class="nf">bubbleSort</span><span class="p">(</span> <span class="n">list</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">)</span>
  <span class="p">{</span>                                                       <span class="cm">/* 用冒泡排序法对r[1]…r[n]进行排序 */</span>
  	<span class="cm">/* flag:标志文件是否已排好序 */</span>
  	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
  	<span class="p">{</span>
  		<span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>                               <span class="cm">/* 若循环中记录未作交换,则说明序列已有序 */</span>
  		<span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">)</span>
  			<span class="k">if</span> <span class="p">(</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="p">)</span>
  			<span class="p">{</span>
  				<span class="n">flag</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="cm">/* 排序前先为0，若在一趟起泡中交换了记录，则置为1 */</span>
  				<span class="n">p</span>		<span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
  				<span class="n">r</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>	<span class="o">=</span> <span class="n">p</span><span class="p">;</span>
  			<span class="p">}</span>
  		<span class="k">if</span> <span class="p">(</span> <span class="n">flag</span> <span class="p">)</span>
  			<span class="k">return</span><span class="p">;</span>
  	<span class="p">}</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></div>        </div>
      </li>
    </ul>
  </li>
  <li>快速排序</li>
  <li>基本思想：通过分部排序完成整个表的排序；首先取第一个记录，将之与表中其余记录比较并交换，从而将它放到记录的正确的最终位置，使记录表分成两部分{其一（左边的）诸记录的关键字均小于它；其二（右边的）诸记录的关键字均大于它}；然后对这两部分重新执行上述过程，依此类推，直至排序完毕
```c
void  quickpass( list r, int h, int p )
{
  /* 对顺序表r中的子序列r[h]至r[p]进行快速排序 <em>/
  i	= h;    j = p;  /</em> 左右指针置初值 <em>/
  x	= r[h];         /</em> 取处理元素（即作为枢轴记录） <em>/
  while ( i ＜ j  )       /</em> 左右指针未碰头则反复做： <em>/
  {
      while ( r[j].key &gt; x.key &amp;&amp; i &lt; j )
          –j;
      /</em>右边未找到小关键字，则右指针j继续左移<em>/
      if ( i &lt; j )    /</em>右边找到比枢轴记录小的记录，则将其送到左边<em>/
      {
          r[i] = r[j];
          ++i;
      }
      while ( r[i].key &lt;= x.key &amp;&amp; i &lt; j )
          ++i;
      /</em>边未找到大关键字，则左指针i继续右移<em>/
      if ( i &lt; j )                    /</em>左边找到比枢轴记录大的记录，则将其送到右边<em>/
      {
          r[j] = r[i];
          - -j;
      }
  }
  r[i] = x;                               /</em>枢轴记录定位<em>/
  if ( h &lt; i - 1 )
      quickpass( r, h, i - 1 );       /</em>对左子序列进行快速排序<em>/
  if ( j + 1 &lt; high )
      quickpass( r, j + 1, p );       /</em>对右子序列进行快速排序*/
}</li>
</ul>

<p>```</p>
<ul>
  <li>算法分析
    <ul>
      <li>空间：n+log2n; （log2n为附加空间—栈）</li>
      <li>时间：≤O(nlog2n);
        <ul>
          <li>注：若初始记录表有序或基本有序，则快速排序将蜕化为冒泡排序，其时间复杂度为O(n2)；</li>
          <li>即：快速排序在表基本有序时，最不利于其发挥效率。</li>
        </ul>
      </li>
      <li>稳定性：不稳定排序。</li>
    </ul>
  </li>
</ul>

<h3 id="4-选择排序"><span class="mr-2">4 选择排序</span><a href="#4-选择排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<ul>
  <li>直接选择：以重复选择的思想为基础进行排序
    <ul>
      <li>过程：设记录R_1，R_2…，R_n，对i=1，2，…，n-1，重复下列工作：
        <ul>
          <li>在R_i，…，R_n中选最小(或最大)关键字记录R_j；</li>
          <li>将R_j与第i个记录交换位置，即将选到的第i小的记录换到第i号位置上
            <div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>  <span class="kt">void</span>  <span class="nf">select</span><span class="p">(</span> <span class="n">list</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">)</span>
  <span class="p">{</span>
  	<span class="cm">/*用选择排序法对r[1]….r[n]进行排序*/</span>
  	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
  	<span class="p">{</span>
  		<span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>                                  <span class="cm">/*选择第i小的记录，并交换位*/</span>
  		<span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">)</span>
  			<span class="k">if</span> <span class="p">(</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">key</span> <span class="p">)</span>      <span class="cm">/*在r.[i]…r.[n-1]中找最小者*/</span>
  				<span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
  		<span class="k">if</span> <span class="p">(</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">i</span> <span class="p">)</span>                           <span class="cm">/*交换记录*/</span>
  		<span class="p">{</span>
  			<span class="n">temp</span>	<span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  			<span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>	<span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
  			<span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>	<span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
  		<span class="p">}</span>
  	<span class="p">}</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></div>            </div>
          </li>
        </ul>
      </li>
      <li>分析
        <ul>
          <li>空间：n+1； （1为附加空间）</li>
          <li>时间：C总=∑ni=1(n-i)=(n2–1)/2≈O(n2)</li>
          <li>稳定性：不稳定排序；</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>堆排序
    <ul>
      <li>需要解决问题
        <ul>
          <li>如何由一个初始序列建成一个堆？</li>
          <li>如何在输出堆元素之后调整剩余元素成为一个新堆？</li>
        </ul>
      </li>
      <li>分析
        <ul>
          <li>空间：n+1； （仅需1个附加空间）</li>
          <li>时间：O（nlog2n)</li>
          <li>稳定性：不稳定排序；
            <h3 id="5-并归排序"><span class="mr-2">5 并归排序</span><a href="#5-并归排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>有序序列的合并：比较各个子序列的第一个记录的键值，最小的一个就是排序后序列的第一个记录。取出这个记录，继续比较各子序列现有的第一个记录的键值，便可找出排序后的第二个记录。如此继续下去，最终可以得到排序结果</li>
  <li>二种并归排序
    <ul>
      <li>思路
        <ul>
          <li>n个记录的表看成n个，长度为1的有序表</li>
          <li>两两归并成 n/2 个，长度为2的有序表（n为奇数，则还有1个长为1的表）</li>
          <li>再两两归并为  n/2 /2 个，长度为4的有序表，再两两归并直至只剩1个，长度为n的有序表，共log2n趟</li>
        </ul>
      </li>
      <li>算法分析
        <ul>
          <li>空间：n+n；（需n个附加空间）</li>
          <li>时间：O（nlogn)</li>
          <li>稳定性：稳定排序；
            <h3 id="6-小结"><span class="mr-2">6 小结</span><a href="#6-小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th>排序方法</th>
      <th>平均时间</th>
      <th>最坏情况</th>
      <th>辅助存储</th>
      <th>稳定性</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>简单排序(插入、冒泡、直接选择)</td>
      <td>O(n2)</td>
      <td>O(n2)</td>
      <td>O(1)</td>
      <td>稳定排序(除直接选择是不稳定外)</td>
    </tr>
    <tr>
      <td>快速排序</td>
      <td>O(nlog2n)</td>
      <td>O(n2)</td>
      <td>O(log2n)</td>
      <td>不稳定排序</td>
    </tr>
    <tr>
      <td>堆排序</td>
      <td>O(nlog2n)</td>
      <td>O(nlog2n)</td>
      <td>O(1)</td>
      <td>不稳定排序</td>
    </tr>
    <tr>
      <td>归并排序</td>
      <td>O(nlog2n)</td>
      <td>O(nlog2n)</td>
      <td>O(n)</td>
      <td>稳定排序</td>
    </tr>
  </tbody>
</table></div>

</div>

<div class="post-tail-wrapper text-muted">

  <!-- categories -->
  
  <div class="post-meta mb-3">
    <i class="far fa-folder-open fa-fw mr-1"></i>
    
      <a href='/blog.github.io/categories/computerbasics/'>ComputerBasics</a>
  </div>
  

  <!-- tags -->
  
  <div class="post-tags">
    <i class="fa fa-tags fa-fw mr-1"></i>
      
      <a href="/blog.github.io/tags/datastructure/"
          class="post-tag no-text-decoration" >DataStructure</a>
      
      <a href="/blog.github.io/tags/selfstudy/"
          class="post-tag no-text-decoration" >SelfStudy</a>
      
  </div>
  

  <div class="post-tail-bottom
    d-flex justify-content-between align-items-center mt-3 pt-5 pb-2">
    <div class="license-wrapper">

      

        

        本文由作者按照 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         进行授权

      
    </div>

    <!--
 Post sharing snippet
-->

<div class="share-wrapper">
  <span class="share-label text-muted mr-1">分享</span>
  <span class="share-icons">
    
    
    

    

    <i id="copy-link" class="fa-fw fas fa-link small"
        data-toggle="tooltip" data-placement="top"
        title="分享链接"
        data-title-succeed="链接已复制！">
    </i>

  </span>
</div>


  </div><!-- .post-tail-bottom -->

</div><!-- div.post-tail-wrapper -->


      
    
    

    </div>
  </div> <!-- #core-wrapper -->

  <!-- pannel -->
  <div id="panel-wrapper" class="col-xl-3 pl-2 text-muted">

    <div class="access">
      















  <div id="access-lastmod" class="post">
    <div class="panel-heading">最近更新</div>
    <ul class="post-content pl-0 pb-1 ml-1 mt-2">
      
        
        
        
      <li><a href="/blog.github.io/posts/Interview/">Golang面试</a></li>
      
        
        
        
      <li><a href="/blog.github.io/posts/reactBase/">React 基础</a></li>
      
        
        
        
      <li><a href="/blog.github.io/posts/redis-all/">Redis 汇总</a></li>
      
        
        
        
      <li><a href="/blog.github.io/posts/kubectl/">Kubectl</a></li>
      
        
        
        
      <li><a href="/blog.github.io/posts/mapAndContainer/">Day09（MapAndContainer）</a></li>
      
    </ul>
  </div> <!-- #access-lastmod -->



      















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <div id="access-tags">
    <div class="panel-heading">热门标签</div>
    <div class="d-flex flex-wrap mt-3 mb-1 mr-3">

    
      
      <a class="post-tag" href="/blog.github.io/tags/golang/">golang</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/gobase/">GoBase</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/goutils/">GoUtils</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/goadvanced/">GoAdvanced</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/network/">network</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/docker/">Docker</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/goweb/">GoWeb</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/kubernetes/">Kubernetes</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/mysql/">Mysql</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/selfstudy/">SelfStudy</a>
    

    </div>
  </div>


    </div>

    
      
      



<!-- BS-toc.js will be loaded at medium priority -->
<script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script>

<div id="toc-wrapper" class="pl-0 pr-4 mb-5">
  <div class="panel-heading pl-3 pt-2 mb-2">文章内容</div>
  <nav id="toc" data-toggle="toc"></nav>
</div>


    
  </div>

</div>

<!-- tail -->

<div class="row">
  <div class="col-12 col-lg-11 col-xl-8">
    <div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4">
      
        
        <!--
 Recommend the other 3 posts according to the tags and categories of the current post,
 if the number is not enough, use the other latest posts to supplement.
-->

<!-- The total size of related posts  -->


<!-- An random integer that bigger than 0  -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy}  -->








  

  
    
  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  








<!-- Fill with the other newlest posts  -->





  <div id="related-posts" class="mt-5 mb-2 mb-sm-4">
    <h3 class="pt-2 mt-1 mb-4 ml-1"
      data-toc-skip>相关文章</h3>
    <div class="card-deck mb-4">
    
      
      
      <div class="card">
        <a href="/blog.github.io/posts/InternetPrinciples/">
          <div class="card-body">
            <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->





<em class="small"
    data-ts="1616219821"
    data-df="YYYY-MM-DD"
    >
  2021-03-20
</em>

            <h3 class="pt-0 mt-1 mb-3" data-toc-skip>InternetPrinciples（04735）</h3>
            <div class="text-muted small">
              <p>
                





                第一章 计算机概述
1 计算机网络基本概念
网络协议
- 网络通讯实体之间的在数据交换过程中需要遵循的规则或约定
- 三要素
    - 语法（syntax）
    - 语义（semantics）
    - 时序（timing） #### 网络功能（核心功能：资源共享）
- 硬件资源共享
- 软件资源共享
- 信息资源共享 #### 网络分类
- 按覆盖范围分类
    - 个域网：PA...
              </p>
            </div>
          </div>
        </a>
      </div>
    
      
      
      <div class="card">
        <a href="/blog.github.io/posts/databases/">
          <div class="card-body">
            <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->





<em class="small"
    data-ts="1576821421"
    data-df="YYYY-MM-DD"
    >
  2019-12-20
</em>

            <h3 class="pt-0 mt-1 mb-3" data-toc-skip>Databases（04735）</h3>
            <div class="text-muted small">
              <p>
                





                数据库系统原理（04735）

第一章数据库系统概述

第三节数据库系统的结构

模式：物理独立性 外模式：逻辑独立性


  数据库系统结构
    
      客户端系统结构
      浏览器/服务器结构
        
          表示层、处理层、数据层
        
      
    
  


第四节数据模型


  数据模型的分类：概念层数据模型、逻辑层数据...
              </p>
            </div>
          </div>
        </a>
      </div>
    
      
      
      <div class="card">
        <a href="/blog.github.io/posts/NetworkEngineerBase/">
          <div class="card-body">
            <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->





<em class="small"
    data-ts="1566103734"
    data-df="YYYY-MM-DD"
    >
  2019-08-18
</em>

            <h3 class="pt-0 mt-1 mb-3" data-toc-skip>网络基础</h3>
            <div class="text-muted small">
              <p>
                





                计算机网络基础

OSI与TCP/IP

OSI

TCP/IP

物理层


  网络接口


网际层


  IP协议：主要的网际层协议，用于网络互联
  ICMP协议：报文协议，用于报告差错，向路由器主机发送差错报文
  ARP协议：地址解析协议，用于将IP 解析成物理地址
  RARP协议：逆地址协议，物理地址解析到IP地址


运输层


  TCP：传输控制协议是面向连接协议，提...
              </p>
            </div>
          </div>
        </a>
      </div>
    
    </div> <!-- .card-deck -->
  </div> <!-- #related-posts -->


      
        
        <!--
  Navigation buttons at the bottom of the post.
-->

<div class="post-navigation d-flex justify-content-between">
  
  <a href="/blog.github.io/posts/reactProject/" class="btn btn-outline-primary"
    prompt="上一篇">
    <p>React Project</p>
  </a>
  

  
  <div class="btn btn-outline-primary disabled"
    prompt="下一篇">
    <p>-</p>
  </div>
  

</div>

      
        
        <!--  The comments switcher -->


      
    </div>
  </div>
</div> <!-- .row -->



        <!--
  The Footer
-->

<footer class="d-flex w-100 justify-content-center">
  <div class="d-flex justify-content-between align-items-center text-muted">
    <div class="footer-left">
      <p class="mb-0">
        © 2022
        <a href="https://Cc360428.github.io/cc/">Cc</a>.
        
        <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span>
        
      </p>
    </div>

    <div class="footer-right">
      <!-- <p class="mb-0">
        

        

        本站由 
        <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>
         生成，采用 
        <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a>
         主题。

      </p> -->
    </div>

  </div> <!-- div.d-flex -->
</footer>


      </div>

      <!--
  The Search results
-->
<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-12 col-sm-11 post-content">
    <div id="search-hints">
      















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <div id="access-tags">
    <div class="panel-heading">热门标签</div>
    <div class="d-flex flex-wrap mt-3 mb-1 mr-3">

    
      
      <a class="post-tag" href="/blog.github.io/tags/golang/">golang</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/gobase/">GoBase</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/goutils/">GoUtils</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/goadvanced/">GoAdvanced</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/network/">network</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/docker/">Docker</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/goweb/">GoWeb</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/kubernetes/">Kubernetes</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/mysql/">Mysql</a>
    
      
      <a class="post-tag" href="/blog.github.io/tags/selfstudy/">SelfStudy</a>
    

    </div>
  </div>


    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>


    </div> <!-- #main-wrapper -->

    

    <div id="mask"></div>

    <a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button">
      <i class="fas fa-angle-up"></i>
    </a>

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script>

<script>
SimpleJekyllSearch({
  searchInput: document.getElementById('search-input'),
  resultsContainer: document.getElementById('search-results'),
  json: '/blog.github.io/assets/js/data/search.json',
  searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0">  <a href="{url}">{title}</a>  <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">    {categories}    {tags}  </div>  <p>{snippet}</p></div>',
  noResultsText: '<p class="mt-5">搜索结果为空</p>',
  templateMiddleware: function(prop, value, template) {
    if (prop === 'categories') {
      if (value === '') {
        return `${value}`;
      } else {
        return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
      }
    }

    if (prop === 'tags') {
      if (value === '') {
        return `${value}`;
      } else {
        return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
      }
    }
  }
});
</script>


    <!--
  JS selector for site.
-->

<!-- layout specified -->


  



  <!-- image lazy-loading & popup & clipboard -->
  

  







  
    

    

  



  
    

    

  



  
    

    

  




  <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script>







  

  

  







  
    

    

  



  
    

    

  



  
    

    

  



  
    

    

  




  <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script>








<script defer src="/blog.github.io/assets/js/dist/post.min.js"></script>



<!-- commons -->

<script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script>




  </body>

</html>

